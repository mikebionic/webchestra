<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beat Mixer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #fff;
        }
        
        h1 {
            font-size: 2.5em;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            color: #00ffff;
        }
        
        .instructions {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }
        
        .stage {
            display: flex;
            gap: 30px;
            margin-bottom: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .character {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 4px solid #333;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            background: linear-gradient(135deg, #2a2a3e 0%, #3a3a5e 100%);
            position: relative;
        }
        
        .character:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }
        
        .character.active {
            border-color: #00ffff;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .character-label {
            position: absolute;
            bottom: -30px;
            font-size: 0.4em;
            color: #aaa;
            text-align: center;
            width: 100%;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        button {
            padding: 15px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        #resetBtn {
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
            color: white;
        }
        
        #resetBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 65, 108, 0.4);
        }
        
        .sound-type-1 { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .sound-type-2 { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .sound-type-3 { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .sound-type-4 { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); }
        .sound-type-5 { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); }
        .sound-type-6 { background: linear-gradient(135deg, #30cfd0 0%, #330867 100%); }
    </style>
</head>
<body>
    <h1>üéµ Beat Mixer üéµ</h1>
    
    <div class="instructions">
        Click on characters to layer different sounds and create your mix!
    </div>
    
    <div class="stage" id="stage"></div>
    
    <div class="controls">
        <button id="resetBtn">Reset All</button>
    </div>

    <script>
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        const sounds = [
            { 
                emoji: 'üé∏', 
                name: 'Bass', 
                type: 1, 
                notes: [98.00, 116.54, 87.31, 130.81, 155.56, 196.00, 146.83, 185.00, 73.42], // A2, D3, E3
                pattern: [1,0,0,1,2,1,0,1,0,1,0,1,2,1,3, 0, 1,0,0,1,2,1,0,1,0,1,0,1,2,1,3, 0, 4,0,0,4,5,4,0,4,0,4,0,4,5,4,6, 0, 7,0,0,7,8,7,0,9,0,0,0],
                // pattern: [1,0,0,1,2,1,0,1,0,1,0,1,2,1,3],
                // pattern: [4,0,0,4,5,4,0,4,0,4,0,4,5,4,6],
                // pattern: [7,0,0,7,8,7,0,9,0,0],
                notePattern: true
            },


// G2, Bb, F, C, Eb, G3
// G2 ‚Üí 98.00 Hz

// Bb2 ‚Üí 116.54 Hz

// F2 ‚Üí 87.31 Hz

// C3 ‚Üí 130.81 Hz

// Eb3 ‚Üí 155.56 Hz

// G3 ‚Üí 196.00 Hz

// D3 ‚Üí 146.83 Hz

// F#3 ‚Üí 185.00 Hz

// D2 ‚Üí 73.42 Hz

            { 
                emoji: 'ü•Å', 
                name: 'Kick', 
                type: 2, 
                freq: 100, // Lower frequency for punchier kick
                pattern: [1,0,0,1,0,1,0,0],
                isDrum: true
            },
            { 
                emoji: 'üé∫', 
                name: 'Snare', 
                type: 3, 
                freq: 30, 
                pattern: [0,0,1,0,0,0,1,0],
                isDrum: true,
                useNoise: true // Add noise for snare
            },
            { 
                emoji: 'üé§', 
                name: 'Hi-Hat', 
                type: 4, 
                freq: 8000, 
                pattern: [1,1,1,1,1,1,1,1],
                isDrum: true,
                useNoise: true
            },
            { 
                emoji: 'üé§', 
                name: 'Synth', 
                type: 5, 
                notes: [523.25, 587.33, 659.25, 783.99], // C5, D5, E5, G5
                pattern: [0,0,1,0,2,0,3,0],
                notePattern: true
            },
            {
                emoji: 'üéß',
                name: 'Lead',
                type: 6,
                notes: [392.00, 587.33, 554.37, 466.16, 523.25, 739.99, 622.25, 880.00, 784.00], // G4, D5, C#5, Bb4, C5, F#5, Eb4, A5, G5
                pattern: [1,2,0,1,3,2,3,4, 1,2,0,1,3,2,3,4, 1,2,0,1,3,2,3,4, 1,2,0,1,3,2,3,4, 5,9,0,5,6,9,6,7, 5,9,0,5,6,9,6,7, 2,8,0,2,6,2,0,5,0],
                notePattern: true
            }
        ];
                
        const activeOscillators = {};
        const gainNodes = {};
        let currentBeat = 0;
        let isPlaying = false;
        let intervalId = null;
        
        function createCharacter(sound, index) {
            const char = document.createElement('div');
            char.className = `character sound-type-${sound.type}`;
            char.innerHTML = `${sound.emoji}<div class="character-label">${sound.name}</div>`;
            char.dataset.index = index;
            
            char.addEventListener('click', () => toggleSound(index));
            
            return char;
        }
        
        function toggleSound(index) {
            const char = document.querySelector(`[data-index="${index}"]`);
            
            if (activeOscillators[index]) {
                stopSound(index);
                char.classList.remove('active');
            } else {
                startSound(index);
                char.classList.add('active');
            }
        }
        
        function startSound(index) {
            const sound = sounds[index];
            
            if (sound.isDrum) {
                // For drums, create the oscillator normally
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                if (sound.useNoise) {
                    // Use noise for snare/hihat
                    const bufferSize = audioContext.sampleRate * 0.5;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const output = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                    const noise = audioContext.createBufferSource();
                    noise.buffer = buffer;
                    noise.loop = true;
                    
                    const filter = audioContext.createBiquadFilter();
                    filter.type = index === 3 ? 'highpass' : 'bandpass';
                    filter.frequency.setValueAtTime(index === 3 ? 5000 : 10000, audioContext.currentTime);
                    
                    noise.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    
                    noise.start();
                    activeOscillators[index] = noise;
                } else {
                    // Kick drum
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(sound.freq, audioContext.currentTime);
                    
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(500, audioContext.currentTime);
                    
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    
                    oscillator.start();
                    activeOscillators[index] = oscillator;
                }
                
                gainNodes[index] = gainNode;
            } else {
                // For melodic instruments, store the notes
                activeOscillators[index] = { notes: sound.notes, type: 'melodic' };
                gainNodes[index] = null;
            }
            
            if (!isPlaying) {
                startBeat();
            }
        }
        
        function stopSound(index) {
            if (activeOscillators[index]) {
                const sound = sounds[index];
                
                if (sound.isDrum) {
                    // For drums with gainNode
                    const gainNode = gainNodes[index];
                    if (gainNode) {
                        gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                        
                        setTimeout(() => {
                            if (activeOscillators[index] && activeOscillators[index].stop) {
                                activeOscillators[index].stop();
                            }
                            delete activeOscillators[index];
                            delete gainNodes[index];
                            
                            if (Object.keys(activeOscillators).length === 0) {
                                stopBeat();
                            }
                        }, 100);
                    }
                } else {
                    // For melodic instruments, just remove from active list
                    delete activeOscillators[index];
                    delete gainNodes[index];
                    
                    if (Object.keys(activeOscillators).length === 0) {
                        stopBeat();
                    }
                }
            }
        }

        function startBeat() {
            if (isPlaying) return;
            isPlaying = true;
            
            intervalId = setInterval(() => {
                Object.keys(activeOscillators).forEach(index => {
                    const sound = sounds[index];
                    
                    if (sound.notePattern) {
                        // Play melodic notes
                        const noteIndex = sound.pattern[currentBeat % 64];
                        if (noteIndex > 0) {
                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();
                            
                            osc.type = index == 0 ? 'triangle' : index == 4 ? 'square' : 'sine';
                            osc.frequency.setValueAtTime(sound.notes[noteIndex - 1], audioContext.currentTime);
                            
                            gain.gain.setValueAtTime(0.15, audioContext.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);
                            
                            osc.connect(gain);
                            gain.connect(audioContext.destination);
                            osc.start();
                            osc.stop(audioContext.currentTime + 0.4);
                        }
                    } else {
                        // Play drum sounds
                        const gainNode = gainNodes[index];
                        if (gainNode && sound.pattern[currentBeat % 8]) {
                            gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                            
                            if (index === 1) {
                                // Kick - punchier envelope
                                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
                                
                                // Pitch drop for kick
                                if (activeOscillators[index].frequency) {
                                    activeOscillators[index].frequency.setValueAtTime(150, audioContext.currentTime);
                                    activeOscillators[index].frequency.exponentialRampToValueAtTime(55, audioContext.currentTime + 0.1);
                                }
                            } else {
                                // Snare and hihat
                                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                            }
                        }
                    }
                });
                
                currentBeat++;
            }, 200);
        }
        
        function stopBeat() {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            isPlaying = false;
            currentBeat = 0;
        }
        
        function resetAll() {
            Object.keys(activeOscillators).forEach(index => {
                stopSound(index);
                const char = document.querySelector(`[data-index="${index}"]`);
                char.classList.remove('active');
            });
        }
        
        const stage = document.getElementById('stage');
        sounds.forEach((sound, index) => {
            stage.appendChild(createCharacter(sound, index));
        });
        
        document.getElementById('resetBtn').addEventListener('click', resetAll);
    </script>
</body>
</html>
